<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" []>
<chapter id="rest.client">
	<title>RESTEasy Client Framework Integration</title>

	<para>
		The RESTEasy Client Framework is a framework for writing clients
		for
		REST-based web services. It reuses JAX-RS metadata for creating
		HTTP
		requests. For more information about the framework, refer to the
		<ulink
			url="http://docs.jboss.org/resteasy/docs/2.0.0.GA/userguide/html/RESTEasy_Client_Framework.html">project documentation</ulink>
		.
	</para>

	<para>
		Integration with the RESTEasy Client Framework is optional in
		Seam REST and only available when RESTEasy is available on classpath.
	</para>

	<sect1>
		<title>Using RESTEasy Client Framework with Seam REST</title>

		<para>
			Let's have the <literal>TaskService</literal> sample interface. A remote server
			implements this interface exposing a web service for getting task
			details.
		</para>

		<example>
			<title>Sample JAX-RS annotated interface</title>
			<programlisting role="JAVA"><![CDATA[@Path("/task")
@Produces("application/xml")
public interface TaskService
{
	@GET
	@Path("/{id}")
	Task getTask(@PathParam("id")long id);
}]]></programlisting>
		</example>

		<para>
			To access the remote web service, let Seam REST build and inject a client object of the web service.
		</para>

		<example>
			<title>Injecting REST Client</title>
			<programlisting role="JAVA"><![CDATA[@Inject @RestClient("http://example.com")
private TaskService taskService;

...

Task task = taskService.getTask(1);
]]></programlisting>
		</example>

		<para>
			What really happens is that the Seam REST module injects a
			proxied <literal>TaskService</literal> interface. Under the hood, the RESTEasy Client
			Framework converts every method invocation on the <literal>TaskService</literal> to an
			HTTP request and sends it over the wire to <literal>http://example.com</literal>. The
			HTTP response is unmarshalled automatically and the response object
			is returned by the method call.
		</para>
		
		<para>
			In addition, it is possible to use EL expressions within the URI. 
		</para>
		
		<programlisting role="JAVA"><![CDATA[@Inject @RestClient("#{example.service.uri}")]]></programlisting>
		
	</sect1>

	<sect1>
		<title>Manual ClientRequest API</title>
		<para>
			Besides proxying JAX-RS interfaces, the RESTEasy Client Framework
			provides the ClientRequest API for building the HTTP requests
			manually. For more information on the ClientRequest API, refer to the
			<ulink
				url=" http://docs.jboss.org/resteasy/docs/2.0.0.GA/userguide/html/RESTEasy_Client_Framework.html#ClientRequest">project documentation</ulink>
		</para>

		<example>
			<title>Injecting ClientRequest</title>
			<programlisting role="JAVA"><![CDATA[@Inject @RestClient("http://localhost:8080/test/ping")
private ClientRequest request;

...

request.accept(MediaType.TEXT_PLAIN_TYPE);
ClientResponse<String> response = request.get(String.class);]]></programlisting>
		</example>
	</sect1>

	<sect1>
		<title>ClientExecutor configuration</title>
		<para>
			If not specified otherwise, every request is executed by a default Apache HTTP Client 4 configuration.
			This can be altered by providing a ClientExecutor bean.
		</para>
		
				<example>
			<title>Custom Apache HTTP Client 4 configuration</title>
			<programlisting role="JAVA"><![CDATA[@Produces
public ClientExecutor createExecutor()
{
	HttpParams params = new BasicHttpParams();
    ConnManagerParams.setMaxTotalConnections(params, 3);
    ConnManagerParams.setTimeout(params, 1000);

    SchemeRegistry schemeRegistry = new SchemeRegistry();
    schemeRegistry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80));

    ClientConnectionManager cm = new ThreadSafeClientConnManager(params, schemeRegistry);
    HttpClient httpClient = new DefaultHttpClient(cm, params);

    return new ApacheHttpClient4Executor(httpClient);
}]]></programlisting>
		</example>
	</sect1>
</chapter>